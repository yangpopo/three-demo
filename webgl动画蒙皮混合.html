<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>three.js-webgl动画蒙皮混合-webgl_animation_skinning_blending</title>
  <meta name="description" content="Three.js 是一款运行在浏览器中的 3D 引擎，你可以用它在 web 中创建各种三维场景，包括了摄影机、光影、材质等各种对象。">
  <meta name="keywords" content="3d,WebGL">
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    .animation-menu {
      position: absolute;
      top: 0;
      right: 0;
      padding: 0;
      margin: 0;
    }
    .animation-menu li {
      background-color: #fff;
      box-sizing: border-box;
      padding: 5px 30px;
      list-style: none;
      font-size: 14px;
      margin: 5px 0;
      text-align: center;
      cursor: pointer;
      z-index: 9;
    }
    
  </style>
</head>

<body>
  <ul class="animation-menu">
    <li id="Idle">动画-等待-Idle</li>
    <li id="Run">动画-跑-Run</li>
    <li id="TPose">动画-T姿态-TPose</li>
    <li id="Walk">动画-步行-Walk</li>
    <li>等待-Idle-权重<input id="IdleWeight" type="range" max="100" min="0" value="100"></li>
    <li>跑-Run-权重<input id="RunWeight" type="range" max="100" min="0" value="0"></li>
    <li>步行-Walk-权重<input id="WalkWeight" type="range" max="100" min="0" value="0"></li>
    <li>动画速度<input id="speed" type="range" max="100" min="0"></li>
  </ul>
  <!-- 引入three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three'; // 引入主包
    import Stats from './jsm/libs/stats.module.js'; // 引入性能监控

    import { TrackballControls } from './jsm/controls/TrackballControls.js'; // 相机控件

    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js'; // 引入加载器

    let mixer; // 动画混合器
    let animationJSON = {}; // 动画数组
    let activation = Object; // 激活动画
    const clock = new THREE.Clock(); // 时间对象
    const stats = new Stats(); //创建监控对象
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    stats.domElement.style.left = '0px';
    document.getElementsByTagName('body')[0].appendChild(stats.domElement);

    const scene = new THREE.Scene(); // 创建场景
    scene.background = new THREE.Color(0xa0a0a0); // 配置场景背景色
    scene.fog = new THREE.Fog( 0xa0a0a0, 1, 50 ); // 场景参数雾

    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000); // 创建摄像机
    camera.position.set(5, 2, 8);
    scene.add(camera);

    // 创建半球光线
    const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, .5);
    hemiLight.position.set( 0, 10, 0 );
    scene.add(hemiLight); 

    // 创建一个虚拟的球形网格 Mesh 的辅助对象来模拟 半球形光源 HemisphereLight.
    const hemiLighthelper = new THREE.HemisphereLightHelper(hemiLight, 5);
    scene.add(hemiLighthelper);


    // 创建点聚光灯
    const spotLight = new THREE.SpotLight(0xffffff, 1, 100, Math.PI/2, 0.1, 0.1);
    spotLight.shadowCameraVisible = true; // 显示灯光的位置
    spotLight.position.set(15, 10, 10);
    spotLight.castShadow = true;
    spotLight.shadow.camera.visible = true;
    spotLight.shadow.mapSize.width = 2048;
    spotLight.shadow.mapSize.height = 2048;
    spotLight.shadow.focus = 0.25; // 集中
    spotLight.shadow.camera.near = 10; // 近的
    spotLight.shadow.camera.far = 10; // 远
    spotLight.shadow.camera.fov = 1; // 视野
    scene.add(spotLight);

    // 用于模拟场景中平行光 DirectionalLight 的辅助对象. 其中包含了表示光位置的平面和表示光方向的线段.
    const directionalLightHelper = new THREE.DirectionalLightHelper(spotLight, 1);
    scene.add(directionalLightHelper);


    // 辅助坐标
    const axesHelper = new THREE.AxesHelper( 5 );
    scene.add( axesHelper );

    // 创建地面
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshPhongMaterial( {color: 0x999999, depthWrite: false} );
    const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
    groundPlane.rotation.x = - Math.PI / 2;
    groundPlane.receiveShadow = true; // 产生阴影
    scene.add(groundPlane);

    // 创建加载器--加载模型文件
    const loader = new GLTFLoader();
    loader.load('models/gltf/Soldier.glb', (gltf) => {
        const model = gltf.scene; // 获取模型
        model.scale.set(1.5, 1.5, 1.5); // 缩放模型
        model.rotation.y = - Math.PI / 3 * 2;
        scene.add(model);
        // 模型开启阴影
        model.traverse(function (object) {
          if ( object.isMesh ) object.castShadow = true, object.receiveShadow = true;;
        });

        let skeleton = new THREE.SkeletonHelper( model );
        skeleton.visible = false;
        scene.add(skeleton);

        // 绑定动画
        mixer = new THREE.AnimationMixer(model); // 混合器绑定模型
        for (let i= 0; i < gltf.animations.length; i++) {
          animationJSON[gltf.animations[i].name] = mixer.clipAction(gltf.animations[i]);
        }
        
        // 激活所有动画
        for (let key in animationJSON) {
          // 设置权重
          if(key == 'Idle') {
            animationJSON[key].enabled = true;
            animationJSON[key].setEffectiveTimeScale(1);
            animationJSON[key].setEffectiveWeight(1);
          }
          if(key == 'Run' || key == 'Walk'){
            animationJSON[key].enabled = true;
            animationJSON[key].setEffectiveTimeScale(0);
            animationJSON[key].setEffectiveWeight(0);
          }
          animationJSON[key].play();
        }

        // // 初始化动画
        // animationJSON.Idle.play();
        // activation = animationJSON.Idle; // 初始化激活动画

        animation(); // 更新动画
      }, 
      (res) => {
        console.log('加载进度:', ((res.loaded / res.total) * 100).toFixed(2) + '%')
      }
    );
    

    // 创建渲染器
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio); // 设置像素大小
    renderer.outputEncoding = THREE.sRGBEncoding; // 设置颜色模式
    renderer.shadowMap.enabled = true; // 开启阴影贴图
    document.getElementsByTagName('body')[0].appendChild(renderer.domElement);

    // 相机控制器
    const controls = new TrackballControls(camera, renderer.domElement);
    controls.target = new THREE.Vector3(0, 1, 0);

    function animation() {
      stats.update(); // 刷新统计
      controls.update(); // 刷新控制器
      const delta = clock.getDelta();
      mixer.update(delta); // 刷新动画
      renderer.render(scene, camera);
      requestAnimationFrame(animation);
    }
    // 等待
    document.getElementById('Idle').onclick = () => {
      // if (animationJSON.Idle !== activation) {
      //   // 判断当前动画是否和进入动画是同一个
      //   console.log()
      //   activation.fadeOut(0.5) // 淡出当前动画
      // }
      // animationJSON.Idle
      // .reset() // 重置动作
      // .setEffectiveTimeScale(1) // 设置时间比例 以及停用所有的变形
      // .setEffectiveWeight(1)  // 设置权重（weight）以及停止所有淡入淡出
      // .fadeIn(1) // 动画淡入 持续时间 duration
      // .play(); // 播放动画
      // 先淡入后淡出
      for (let key in animationJSON) {
        animationJSON[key].paused = false;
      }
      animationJSON.Walk.enabled = true;
      animationJSON.Walk.setEffectiveTimeScale(1); // 设置时间比例 以及停用所有的变形
      animationJSON.Walk.setEffectiveWeight(1);  // 设置权重（weight）以及停止所有淡入淡出
      animationJSON.Idle.crossFadeTo(animationJSON.Walk, 1, true);
    }
    // 跑
    document.getElementsByTagName('li')[1].onclick = () => {
      animationArray.forEach(animation => {
        animation.stop();
      });
      animationArray[1].play();
    }
    // 模型站立
    document.getElementsByTagName('li')[2].onclick = () => {
      animationArray.forEach(animation => {
        animation.stop();
      });
      animationArray[2].play();
    }
    // 行走
    document.getElementsByTagName('li')[3].onclick = () => {
      animationArray.forEach(animation => {
        animation.stop();
      });
      animationArray[3].play();
    }
    // 动画速度
    document.getElementById('speed').onchange = function(e) {
      mixer.timeScale = this.value / 50
    }
  </script>
</body>
</html>
